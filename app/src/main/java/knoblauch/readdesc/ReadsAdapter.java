package knoblauch.readdesc;

import android.content.Context;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.BaseAdapter;
import android.widget.ImageView;
import android.widget.TextView;

import java.util.ArrayList;
import java.util.List;

public class ReadsAdapter extends BaseAdapter {

    /**
     * @brief - Describe an internal holder class to regroup all the view generated by this adapter. This helps managing precisely
     */
    private static class ReadDescViewHolder {
        public TextView nameView;
        public TextView sourceView;
        public TextView dateView;
        public TextView completionView;

        public ImageView play;
        public ImageView delete;
    }

    /**
     * @brief - The internal list of reads handled by this adapter.
     */
    private List<ReadDesc> m_reads;

    /**
     * @brief - Allows to perform the inflation of views before they get added to the layout.
     */
    private Context m_context;

    /**
     * @brief - The listener (potentially null) to which notifications for clicks on specific
     *          items of reads should be sent.
     */
    private ReadItemClickListener m_listener;

    /**
     * @brief - Creates a new read adapter with the specified context and click listener.
     * @param context - the context into which views will be instantiated. Usually indicates
     *                  the parent activity where a list of the data contained in this item
     *                  will be displayed.
     * @param readsCount - the number of reads to create.
     * @param listener - a custom listener which might want to be notified of clicks on some
     *                   specific buttons of each individual read.
     */
    public ReadsAdapter(Context context, int readsCount, ReadItemClickListener listener) {
        super();

        // Save the internal inflater.
        m_context = context;

        m_listener = listener;

        // Generate random reads.
        m_reads = new ArrayList<>();
        for (int id = 0 ; id < readsCount ; ++id) {
            m_reads.add(new ReadDesc("Read " + id,"Website " + id, "2020-01-0" + id));
        }
    }

    /**
     * @brief - Used by external elements to remove a read from the internal list.
     * @param desc - the read to remove.
     */
    public void removeItem(ReadDesc desc) {
        if (desc != null) {
            m_reads.remove(desc);
        }
        notifyDataSetChanged();
    }

    @Override
    public int getCount() {
        return m_reads.size();
    }

    @Override
    public ReadDesc getItem(int position) {
        return m_reads.get(position);
    }

    @Override
    public long getItemId(int position) {
        // TODO: Improve this when the `ReadDesc` class is actually able to provide an identifier.
        return position;
    }

    @Override
    public View getView(final int position, View convertView, ViewGroup parent) {
        // Empty view by default.
        ReadDescViewHolder holder;

        // Check whether the view is being recycled: in this case we don't need
        // to perform an inflation on it.
        if (convertView == null) {
            // Inflate the view through the internal inflater.
            convertView = LayoutInflater.from(m_context).inflate(R.layout.read_list_item, null);

            // We need to create a new holder to remember all the needed views for this item. This will
            // avoid expensive calls to `findViewById` later on.
            holder = new ReadDescViewHolder();
            holder.nameView = convertView.findViewById(R.id.read_item_name);
            holder.sourceView = convertView.findViewById(R.id.read_item_source);
            holder.dateView= convertView.findViewById(R.id.read_item_date);
            holder.completionView= convertView.findViewById(R.id.read_item_completion);

            holder.play = convertView.findViewById(R.id.read_item_play);
            holder.delete = convertView.findViewById(R.id.read_item_delete);

            // Register listeners.
            holder.nameView.setOnClickListener(new View.OnClickListener() {
                @Override
                public void onClick(View v) {
                    if (m_listener != null) {
                        m_listener.onReadItemViewClick(R.id.read_item_name, position);
                    }
                }
            });
            holder.sourceView.setOnClickListener(new View.OnClickListener() {
                @Override
                public void onClick(View v) {
                    if (m_listener != null) {
                        m_listener.onReadItemViewClick(R.id.read_item_source, position);
                    }
                }
            });
            holder.play.setOnClickListener(new View.OnClickListener() {
                @Override
                public void onClick(View v) {
                    if (m_listener != null) {
                        m_listener.onReadItemViewClick(R.id.read_item_play, position);
                    }
                }
            });
            holder.delete.setOnClickListener(new View.OnClickListener() {
                @Override
                public void onClick(View v) {
                    if (m_listener != null) {
                        m_listener.onReadItemViewClick(R.id.read_item_delete, position);
                    }
                }
            });

            convertView.setTag(holder);
        }

        holder = (ReadDescViewHolder)convertView.getTag();

        // Assign the text and other properties to the view (i.e. the actual description of the read).
        ReadDesc desc = m_reads.get(position);

        holder.nameView.setText(desc.getName());
        holder.sourceView.setText(desc.getSource());
        holder.dateView.setText(desc.getDate());
        holder.completionView.setText(String.valueOf(desc.getCompletionPercentage()));

        return convertView;
    }
}
