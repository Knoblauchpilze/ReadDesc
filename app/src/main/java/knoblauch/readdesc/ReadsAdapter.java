package knoblauch.readdesc;

import android.content.Context;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.BaseAdapter;
import android.widget.TextView;

import androidx.annotation.RequiresPermission;

import java.util.ArrayList;
import java.util.List;

public class ReadsAdapter extends BaseAdapter {

    /**
     * @brief - Describe an internal holder class to regroup all the view generated by this adapter. This helps managing precisely
     */
    private static class ReadDescViewHolder {
        public TextView nameView;
        public TextView sourceView;
        public TextView dateView;
        public TextView completionView;
    }

    /**
     * @brief - The internal list of reads handled by this adapter.
     */
    private List<ReadDesc> m_reads;

    /**
     * @brief - Allows to perform the inflation of views before they get added to the layout.
     */
    private Context m_context;

    public ReadsAdapter(Context context, int readsCount) {
        super();

        // Save the internal inflater.
        m_context = context;

        // Generate random reads.
        m_reads = new ArrayList<>();
        for (int id = 0 ; id < readsCount ; ++id) {
            m_reads.add(new ReadDesc("Read " + id,"Website " + id, "2020-01-0" + id));
        }
    }

    /**
     * @brief - Used by external elements to remove a read from the internal list.
     * @param desc - the read to remove.
     */
    public void removeItem(ReadDesc desc) {
        if (desc != null) {
            m_reads.remove(desc);
        }
        notifyDataSetChanged();
    }

    @Override
    public int getCount() {
        return m_reads.size();
    }

    @Override
    public ReadDesc getItem(int position) {
        return m_reads.get(position);
    }

    @Override
    public long getItemId(int position) {
        // TODO: Imprpove this when the `ReadDesc` class is actually able to provide an identifier.
        return position;
    }

    @Override
    public View getView(int position, View convertView, ViewGroup parent) {
        // Empty view by default.
        ReadDescViewHolder holder;

        // Check whether the view is being recycled: in this case we don't need
        // to perform an inflation on it.
        if (convertView == null) {
            // Inflate the view through the internal inflater.
            convertView = LayoutInflater.from(m_context).inflate(R.layout.read_list_item, null);

            // We need to create a new holder to remember all the needed views for this item. This will
            // avoid expensive calls to `findViewById` later on.
            holder = new ReadDescViewHolder();
            holder.nameView = convertView.findViewById(R.id.read_item_name);
            holder.sourceView = convertView.findViewById(R.id.read_item_source);
            holder.dateView= convertView.findViewById(R.id.read_item_date);
            holder.completionView= convertView.findViewById(R.id.read_item_completion);

            convertView.setTag(holder);
        }

        holder = (ReadDescViewHolder)convertView.getTag();

        // Assign the text and other properties to the view (i.e. the actual description of the read).
        ReadDesc desc = m_reads.get(position);

        holder.nameView.setText(desc.getName());
        holder.sourceView.setText(desc.getSource());
        holder.dateView.setText(desc.getDate());
        holder.completionView.setText(String.valueOf(desc.getCompletionPercentage()));

        return convertView;
    }
}
