package knoblauch.readdesc.gui;

import android.content.Context;
import android.content.res.Resources;
import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.net.Uri;
import android.text.format.DateUtils;
import android.util.Log;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.BaseAdapter;
import android.widget.ImageView;
import android.widget.TextView;
import android.widget.Toast;

import java.io.FileNotFoundException;
import java.io.InputStream;
import java.util.Date;

import knoblauch.readdesc.R;
import knoblauch.readdesc.model.ReadDesc;
import knoblauch.readdesc.model.ReadsBank;

public class ReadsAdapter extends BaseAdapter {

    /**
     * Describe an internal holder class to regroup all the view generated by this adapter. This
     * helps managing precisely how the view are allocated and fetched in order not to waste time
     * using the `findViewById` when we know how an element is structured.
     */
    private static class ReadDescViewHolder {
        TextView nameView;
        TextView sourceView;
        TextView dateView;
        TextView completionView;

        ImageView delete;

        ImageView thumbnail;

        ReadItemClickNotifier nameClick;
        ReadItemClickNotifier deleteClick;
    }

    /**
     * The internal list of reads handled by this adapter.
     */
    private ReadsBank m_reads;

    /**
     * Allows to perform the inflation of views before they get added to the layout.
     */
    private Context m_context;

    /**
     * The listener (potentially null) to which notifications for clicks on specific
     * items of reads should be sent.
     */
    private ReadItemClickListener m_listener;

    /**
     * Creates a new read adapter with the specified context and click listener.
     * @param context - the context into which views will be instantiated. Usually indicates
     *                  the parent activity where a list of the data contained in this item
     *                  will be displayed.
     * @param listener - a custom listener which might want to be notified of clicks on some
     *                   specific buttons of each individual read.
     */
    public ReadsAdapter(Context context, ReadItemClickListener listener) {
        super();

        // Save the internal inflater.
        m_context = context;

        m_listener = listener;

        // Generate random reads.
        m_reads = new ReadsBank(m_context, ReadsBank.Ordering.CreationDate);
    }

    /**
     * Used by external elements to remove a read from the internal list.
     * @param desc - the read to remove.
     */
    public void removeItem(ReadDesc desc) {
        if (desc == null) {
            return;
        }

        if (m_reads.remove(desc)) {
            notifyDataSetChanged();
        }
    }

    /**
     * Used by external elements to add a read to the internal list.
     * @param desc - the read to create.
     */
    public void addItem(ReadDesc desc) {
        if (desc == null) {
            return;
        }

        if (m_reads.add(desc)) {
            notifyDataSetChanged();
        }
    }

    /**
     * Used to perform a dump of the content of the reads registered in
     * this adapter to the local storage. This is typically used when the
     * activity using the adapter is closed so that we can restore the
     * reads when the application is relaunched.
     */
    public void save() {
        m_reads.save();
    }

    @Override
    public int getCount() {
        return m_reads.size();
    }

    @Override
    public ReadDesc getItem(int position) {
        return m_reads.getRead(position);
    }

    @Override
    public long getItemId(int position) {
        // TODO: Improve this when the `ReadDesc` class is actually able to provide an identifier.
        return position;
    }

    @Override
    public View getView(int position, View convertView, ViewGroup parent) {
        // Empty view by default.
        ReadDescViewHolder holder;

        // Assign the text and other properties to the view (i.e. the actual description of the read).
        final ReadDesc desc = m_reads.getRead(position);

        // Check whether the view is being recycled: in this case we don't need
        // to perform an inflation on it.
        if (convertView == null) {
            // Inflate the view through the internal inflater.
            convertView = LayoutInflater.from(m_context).inflate(R.layout.read_list_item, null);

            // We need to create a new holder to remember all the needed views for this item. This will
            // avoid expensive calls to `findViewById` later on.
            holder = new ReadDescViewHolder();
            holder.nameView = convertView.findViewById(R.id.read_item_name);
            holder.sourceView = convertView.findViewById(R.id.read_item_source);
            holder.dateView= convertView.findViewById(R.id.read_item_date);
            holder.completionView= convertView.findViewById(R.id.read_item_completion);

            holder.delete = convertView.findViewById(R.id.read_item_delete);

            holder.thumbnail = convertView.findViewById(R.id.read_item_thumbnail);

            // Create listeners.
            holder.nameClick = new ReadItemClickNotifier(R.id.read_item_name, position, m_listener);
            holder.deleteClick = new ReadItemClickNotifier(R.id.read_item_delete, position, m_listener);

            // Register listeners.
            holder.nameView.setOnClickListener(holder.nameClick);
            holder.delete.setOnClickListener(holder.deleteClick);

            convertView.setTag(holder);
        }

        // Retrieve the holder for this view.
        holder = (ReadDescViewHolder)convertView.getTag();

        // Update resources.
        holder.nameView.setText(desc.getName());
        holder.sourceView.setText(UriUtils.condenseUri(desc.getSource(), m_context));
        holder.dateView.setText(getDateString(desc.getLastAccessedDate()));
        holder.completionView.setText(String.valueOf(desc.getCompletionPercentage()));

        if (!desc.hasThumbnail()) {
            holder.thumbnail.setImageResource(android.R.color.transparent);
        }
        else {
            Uri u = Uri.parse(desc.getThumbnailPath());

            try {
                InputStream inStream = m_context.getContentResolver().openInputStream(u);
                Bitmap imgRes = BitmapFactory.decodeStream(inStream);
                holder.thumbnail.setImageBitmap(imgRes);
            }
            catch (FileNotFoundException e) {
                // We could not find the file, display an error indicating that the
                // display might not be accurate.
                String msg = String.format(m_context.getResources().getString(R.string.read_desc_failure_thumbnail_load), desc.getName());
                Toast.makeText(m_context, msg, Toast.LENGTH_SHORT).show();
            }
        }

        // Update information about the read represented by this view.
        holder.nameClick.setViewId(position);
        holder.deleteClick.setViewId(position);

        return convertView;
    }

    /**
     * Used to get a user-friendly way to represent the input date as a string. We will
     * define so called `periods` which will characterize the duration elapsed between
     * the provided data and now.
     * This will result in displays like `a few moments ago`, `yesterday`, etc. This is
     * much friendlier than the brutal representation of the access date.
     * @param date - the date to convert to a user-friendly format.
     * @return - a string representing this date.
     */
    private String getDateString(Date date) {
        // We will use a timetable as follows:
        //  - for an event that happened in the last minute we will display the date
        //    as `A few moments ago`.
        //  - for an event that happened in the last hour we will display the date as
        //    `X minutes ago`.
        //  - for an event that happened in the last 24 hours we will display the date
        //    as `X hours ago`
        //  - for an event happening until last week we will use `Last week`.
        //  - for an event happening no earlier than one year ago we will use a format
        //    like `X weeks ago`.
        //  - for any event occurring before that we will use `More than one year ago`.
        Date now = new Date();

        // Get the time difference between both dates in milliseconds.
        long t = date.getTime();
        long nowT = now.getTime();
        long elapsed = nowT - t;

        Resources res = m_context.getResources();

        // Check for the time elapsed since the input date..
        long step;

        if (elapsed <= DateUtils.MINUTE_IN_MILLIS) {
            // In the last moments.
            return res.getString(R.string.time_few_moments_ago);
        }
        else if (elapsed <= DateUtils.HOUR_IN_MILLIS) {
            // In the last hour.
            step = DateUtils.MINUTE_IN_MILLIS;
        }
        else if (elapsed <= DateUtils.DAY_IN_MILLIS) {
            // In the last day.
            step = DateUtils.HOUR_IN_MILLIS;
        }
        else if (elapsed <= DateUtils.WEEK_IN_MILLIS) {
            // In the last week.
            step = DateUtils.DAY_IN_MILLIS;
        }
        else if (elapsed <= DateUtils.YEAR_IN_MILLIS) {
            // In the last year.
            step = DateUtils.WEEK_IN_MILLIS;
        }
        else {
            // More than a year ago.
            return res.getString(R.string.time_good_old_times);
        }

        // Return the formatted string.
        return DateUtils.getRelativeTimeSpanString(t, nowT, step).toString();
    }
}
