package knoblauch.readdesc.gui;

import android.content.Context;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.BaseAdapter;
import android.widget.ImageView;
import android.widget.TextView;

import knoblauch.readdesc.R;
import knoblauch.readdesc.model.ReadDesc;
import knoblauch.readdesc.model.ReadsBank;

public class ReadsAdapter extends BaseAdapter {

    /**
     * Describe an internal holder class to regroup all the view generated by this adapter. This
     * helps managing precisely how the view are allocated and fetched in order not to waste time
     * using the `findViewById` when we know how an element is structured.
     */
    private static class ReadDescViewHolder {
        TextView nameView;
        TextView sourceView;
        TextView dateView;
        TextView completionView;

        ImageView play;
        ImageView delete;

        ReadItemClickNotifier nameClick;
        ReadItemClickNotifier sourceClick;
        ReadItemClickNotifier playClick;
        ReadItemClickNotifier deleteClick;
    }

    /**
     * The internal list of reads handled by this adapter.
     */
    private ReadsBank m_reads;

    /**
     * Allows to perform the inflation of views before they get added to the layout.
     */
    private Context m_context;

    /**
     * The listener (potentially null) to which notifications for clicks on specific
     * items of reads should be sent.
     */
    private ReadItemClickListener m_listener;

    /**
     * Creates a new read adapter with the specified context and click listener.
     * @param context - the context into which views will be instantiated. Usually indicates
     *                  the parent activity where a list of the data contained in this item
     *                  will be displayed.
     * @param readsCount - the number of reads to create.
     * @param listener - a custom listener which might want to be notified of clicks on some
     *                   specific buttons of each individual read.
     */
    public ReadsAdapter(Context context, int readsCount, ReadItemClickListener listener) {
        super();

        // Save the internal inflater.
        m_context = context;

        m_listener = listener;

        // Generate random reads.
        m_reads = new ReadsBank(ReadsBank.Ordering.CreationDate, readsCount);
    }

    /**
     * Used by external elements to remove a read from the internal list.
     * @param desc - the read to remove.
     */
    public void removeItem(ReadDesc desc) {
        if (desc != null) {
            m_reads.remove(desc);
        }
        notifyDataSetChanged();
    }

    @Override
    public int getCount() {
        return m_reads.size();
    }

    @Override
    public ReadDesc getItem(int position) {
        return m_reads.getRead(position);
    }

    @Override
    public long getItemId(int position) {
        // TODO: Improve this when the `ReadDesc` class is actually able to provide an identifier.
        return position;
    }

    @Override
    public View getView(int position, View convertView, ViewGroup parent) {
        // Empty view by default.
        ReadDescViewHolder holder;

        // Assign the text and other properties to the view (i.e. the actual description of the read).
        final ReadDesc desc = m_reads.getRead(position);

        // Check whether the view is being recycled: in this case we don't need
        // to perform an inflation on it.
        if (convertView == null) {
            // Inflate the view through the internal inflater.
            convertView = LayoutInflater.from(m_context).inflate(R.layout.read_list_item, null);

            // We need to create a new holder to remember all the needed views for this item. This will
            // avoid expensive calls to `findViewById` later on.
            holder = new ReadDescViewHolder();
            holder.nameView = convertView.findViewById(R.id.read_item_name);
            holder.sourceView = convertView.findViewById(R.id.read_item_source);
            holder.dateView= convertView.findViewById(R.id.read_item_date);
            holder.completionView= convertView.findViewById(R.id.read_item_completion);

            holder.play = convertView.findViewById(R.id.read_item_play);
            holder.delete = convertView.findViewById(R.id.read_item_delete);

            // Create listeners.
            holder.nameClick = new ReadItemClickNotifier(R.id.read_item_name, position, m_listener);
            holder.sourceClick = new ReadItemClickNotifier(R.id.read_item_source, position, m_listener);
            holder.playClick = new ReadItemClickNotifier(R.id.read_item_play, position, m_listener);
            holder.deleteClick = new ReadItemClickNotifier(R.id.read_item_delete, position, m_listener);

            // Register listeners.
            holder.nameView.setOnClickListener(holder.nameClick);
            holder.sourceView.setOnClickListener(holder.sourceClick);
            holder.play.setOnClickListener(holder.playClick);
            holder.delete.setOnClickListener(holder.deleteClick);

            convertView.setTag(holder);
        }

        // Retrieve the holder for this view.
        holder = (ReadDescViewHolder)convertView.getTag();

        // Update resources.
        holder.nameView.setText(desc.getName());
        holder.sourceView.setText(desc.getSource());
        holder.dateView.setText(desc.getCreationDate().toString());
        holder.completionView.setText(String.valueOf(desc.getCompletionPercentage()));

        // Update information about the read represented by this view.
        holder.nameClick.setViewId(position);
        holder.sourceClick.setViewId(position);
        holder.playClick.setViewId(position);
        holder.deleteClick.setViewId(position);

        return convertView;
    }
}
