package knoblauch.readdesc.gui;

import android.content.Context;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.BaseAdapter;
import android.widget.ImageView;
import android.widget.TextView;

import java.util.ArrayList;

import knoblauch.readdesc.R;
import knoblauch.readdesc.model.ReadDesc;
import knoblauch.readdesc.model.ReadsBank;

public class ReadsAdapter extends BaseAdapter {

    /**
     * @brief - Describe an internal holder class to regroup all the view generated by this adapter. This
     *          helps managing precisely how the view are allocated and fetched in order not to waste time
     *          using the `findViewById` when we know how an element is structured.
     */
    private static class ReadDescViewHolder {
        public TextView nameView;
        public TextView sourceView;
        public TextView dateView;
        public TextView completionView;

        public ImageView play;
        public ImageView delete;
    }

    /**
     * @brief - The internal list of reads handled by this adapter.
     */
    private ReadsBank m_reads;

    /**
     * @brief - Allows to perform the inflation of views before they get added to the layout.
     */
    private Context m_context;

    /**
     * @brief - The listener (potentially null) to which notifications for clicks on specific
     *          items of reads should be sent.
     */
    private ReadItemClickListener m_listener;

    /**
     * @brief - Creates a new read adapter with the specified context and click listener.
     * @param context - the context into which views will be instantiated. Usually indicates
     *                  the parent activity where a list of the data contained in this item
     *                  will be displayed.
     * @param readsCount - the number of reads to create.
     * @param listener - a custom listener which might want to be notified of clicks on some
     *                   specific buttons of each individual read.
     */
    public ReadsAdapter(Context context, int readsCount, ReadItemClickListener listener) {
        super();

        // Save the internal inflater.
        m_context = context;

        m_listener = listener;

        // Generate random reads.
        m_reads = new ReadsBank(ReadsBank.Ordering.CreationDate, 15);
    }

    /**
     * @brief - Used by external elements to remove a read from the internal list.
     * @param desc - the read to remove.
     */
    public void removeItem(ReadDesc desc) {
        if (desc != null) {
            m_reads.remove(desc);
        }
        notifyDataSetChanged();
    }

    @Override
    public int getCount() {
        return m_reads.size();
    }

    @Override
    public ReadDesc getItem(int position) {
        return m_reads.getRead(position);
    }

    @Override
    public long getItemId(int position) {
        // TODO: Improve this when the `ReadDesc` class is actually able to provide an identifier.
        return position;
    }

    @Override
    public View getView(final int position, View convertView, ViewGroup parent) {
        // Empty view by default.
        ReadDescViewHolder holder;

        // TODO: It seems that we have an issue with the removal of items of the list when they are
        // not in the first batch of view. For example, try removing from the beginning `Read 7`, it
        // will incorrectly label it as `Read 2` which is weird. Maybe we should create a real class
        // instead of an anonymous one because it seems that the `final` does not work well.
        // More precisely I think that we're binding once and for all the view to its position and
        // never changing its index even though we're recycling it for something else thus the prolblem
        // with the position.

        // Assign the text and other properties to the view (i.e. the actual description of the read).
        final ReadDesc desc = m_reads.getRead(position);

        // Check whether the view is being recycled: in this case we don't need
        // to perform an inflation on it.
        if (convertView == null) {
            // Inflate the view through the internal inflater.
            convertView = LayoutInflater.from(m_context).inflate(R.layout.read_list_item, null);

            // We need to create a new holder to remember all the needed views for this item. This will
            // avoid expensive calls to `findViewById` later on.
            holder = new ReadDescViewHolder();
            holder.nameView = convertView.findViewById(R.id.read_item_name);
            holder.sourceView = convertView.findViewById(R.id.read_item_source);
            holder.dateView= convertView.findViewById(R.id.read_item_date);
            holder.completionView= convertView.findViewById(R.id.read_item_completion);

            holder.play = convertView.findViewById(R.id.read_item_play);
            holder.delete = convertView.findViewById(R.id.read_item_delete);

            // Register listeners.
            holder.nameView.setOnClickListener(new View.OnClickListener() {
                @Override
                public void onClick(View v) {
                    if (m_listener != null) {
                        m_listener.onReadItemViewClick(R.id.read_item_name, position, desc.getName());
                    }
                }
            });
            holder.sourceView.setOnClickListener(new View.OnClickListener() {
                @Override
                public void onClick(View v) {
                    if (m_listener != null) {
                        m_listener.onReadItemViewClick(R.id.read_item_source, position, desc.getName());
                    }
                }
            });
            holder.play.setOnClickListener(new View.OnClickListener() {
                @Override
                public void onClick(View v) {
                    if (m_listener != null) {
                        m_listener.onReadItemViewClick(R.id.read_item_play, position, desc.getName());
                    }
                }
            });
            holder.delete.setOnClickListener(new View.OnClickListener() {
                @Override
                public void onClick(View v) {
                    if (m_listener != null) {
                        m_listener.onReadItemViewClick(R.id.read_item_delete, position, desc.getName());
                    }
                }
            });

            convertView.setTag(holder);
        }

        holder = (ReadDescViewHolder)convertView.getTag();

        holder.nameView.setText(desc.getName());
        holder.sourceView.setText(desc.getSource());
        holder.dateView.setText(desc.getCreationDate().toString());
        holder.completionView.setText(String.valueOf(desc.getCompletionPercentage()));

        return convertView;
    }
}
